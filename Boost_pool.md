# Boost.pool

## Вводное слово
Boost.Pool представляет собой очень быстрый алгоритм выделения памяти, быстродействие которого достигается за счет ограничения области применения, т.е. потерей универсальности.

## Принцип работы 
Boost.Pool разделяет сегменты памяти с одинаковым размером. Каждый раз, когда вы запрашиваете память от Boost.Pool, библиотека получает доступ к следующий свободный сегмент и выделяет память из этого сегмента к вам. Весь сегмент не затем отмечен как используется, независимо от того, сколько байтов вы на самом деле нужно от этого сегмента.

Эта концепция управления памятью называется простым сегрегация хранения . Это единственная концепция поддерживается Boost.Pool. Это особенно полезно , если множество объектов одного и того же размера должны быть созданы и уничтожены часто. В этом случае необходимая память может быть обеспечена и быстро высвобождается.

---

## Примеры использования 

### 1) Boost::simple_segregated_storage
Boost.Pool предоставляет класс boost::simple_segregated_storage для создания и управления сегрегированное памяти. 
boost::simple_segregated_storage - класс низкого уровня , который мы обычно не будем использовать в своих программах напрямую.
Все остальные классы от Boost.Pool внутренне основанны на boost::simple_segregated_storage

#### Пример с boost::simple_segregated_storage
```
#include <boost/pool/simple_segregated_storage.hpp>
#include <vector>
#include <cstddef>

int main()
{
  boost::simple_segregated_storage<std::size_t> storage;
  std::vector<char> v(1024);
  storage.add_block(&v.front(), v.size(), 256);

  int *i = static_cast<int*>(storage.malloc());
  *i = 1;

  int *j = static_cast<int*>(storage.malloc_n(1, 512));
  j[10] = 2;

  storage.free(i);
  storage.free_n(j, 1, 512);
}
```
*	size_t качестве параметра шаблона. Этот параметр определяет , какой тип следует использовать для чисел , передаваемых в функции - члены boost::simple_segregated_storage для обозначения, например, размер сегмента памяти.
*	add_block() призван передать блок памяти 1024 байт для хранения . Память обеспечивается вектором V . 
* Третий параметр , передаваемый add_block() Указывает , что блок памяти должна быть разделена на сегменты по 256 байт каждый. Так как суммарный размер блока памяти , составляет 1024 байт, память управляющая хранением данных состоит из четырех сегментов.
*	Вызовы malloc() и malloc_n() запроса памяти от хранения . 
*	В то время как malloc() возвращает указатель на свободный сегмент, malloc_n() возвращает указатель на один или несколько смежных сегментов , которые обеспечивают столько байт в одном блоке по запросу
*	Запрашивает блок с 512 байт с malloc_n(). Этот вызов потребляет два сегмента, так как каждый сегмент составляет 256 байт.
*	В конце примера, все сегменты освобождаются через free() и free_n(). После этих двух вызовов, все сегменты станоятся доступными и могут быть запрошены снова в malloc() или malloc_n()

