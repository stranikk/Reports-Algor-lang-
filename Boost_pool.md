# Boost.pool

## Вводное слово
Boost.Pool представляет собой очень быстрый алгоритм выделения памяти, быстродействие которого достигается за счет ограничения области применения, т.е. потерей универсальности.

## Принцип работы 
Boost.Pool разделяет сегменты памяти с одинаковым размером. Каждый раз, когда вы запрашиваете память от Boost.Pool, библиотека получает доступ к следующий свободный сегмент и выделяет память из этого сегмента к вам. Весь сегмент не затем отмечен как используется, независимо от того, сколько байтов вы на самом деле нужно от этого сегмента.

Эта концепция управления памятью называется простым сегрегация хранения . Это единственная концепция поддерживается Boost.Pool. Это особенно полезно , если множество объектов одного и того же размера должны быть созданы и уничтожены часто. В этом случае необходимая память может быть обеспечена и быстро высвобождается.

---

## Примеры использования 

### 1) Boost::simple_segregated_storage
Boost.Pool предоставляет класс boost::simple_segregated_storage для создания и управления сегрегированное памяти. 
boost::simple_segregated_storage - класс низкого уровня , который мы обычно не будем использовать в своих программах напрямую.
Все остальные классы от Boost.Pool внутренне основанны на boost::simple_segregated_storage

#### Пример с boost::simple_segregated_storage
```
#include <boost/pool/simple_segregated_storage.hpp>
#include <vector>
#include <cstddef>

int main()
{
  boost::simple_segregated_storage<std::size_t> storage;
  std::vector<char> v(1024);
  storage.add_block(&v.front(), v.size(), 256);

  int *i = static_cast<int*>(storage.malloc());
  *i = 1;

  int *j = static_cast<int*>(storage.malloc_n(1, 512));
  j[10] = 2;

  storage.free(i);
  storage.free_n(j, 1, 512);
}
```
*	size_t качестве параметра шаблона. Этот параметр определяет , какой тип следует использовать для чисел , передаваемых в функции - члены boost::simple_segregated_storage для обозначения, например, размер сегмента памяти.
*	add_block() призван передать блок памяти 1024 байт для хранения . Память обеспечивается вектором V . 
* Третий параметр , передаваемый add_block() Указывает , что блок памяти должна быть разделена на сегменты по 256 байт каждый. Так как суммарный размер блока памяти , составляет 1024 байт, память управляющая хранением данных состоит из четырех сегментов.
*	Вызовы malloc() и malloc_n() запроса памяти от хранения . 
*	В то время как malloc() возвращает указатель на свободный сегмент, malloc_n() возвращает указатель на один или несколько смежных сегментов , которые обеспечивают столько байт в одном блоке по запросу
*	Запрашивает блок с 512 байт с malloc_n(). Этот вызов потребляет два сегмента, так как каждый сегмент составляет 256 байт.
*	В конце примера, все сегменты освобождаются через free() и free_n(). После этих двух вызовов, все сегменты станоятся доступными и могут быть запрошены снова в malloc() или malloc_n()

### 2) Boost::object_pool

#### Пример с boost::object_pool
```
#include <boost/pool/object_pool.hpp>

int main()
{
  boost::object_pool<int> pool;

  int *i = pool.malloc();
  *i = 1;

  int *j = pool.construct(2);

  pool.destroy(i);
  pool.destroy(j);
}
```
* В отличие boost::simple_segregated_storage, boost::object_pool знает тип объектов , которые будут храниться в памяти
* Пул в примере просто сегрегирует для хранения int значения.
* Память управляемая пулом , состоит из сегментов, каждый из которых размером с int- 4 байта
*	Другое отличие состоит в том , что вам не нужно , чтобы обеспечить память в boost::object_pool.  Boost::object_pool выделяет память автоматически
*	В примере , вызов malloc() выделить блок памяти с пространством для 32 int значений. malloc() возвращает указатель на первый из этих 32 сегментов , чтобы int значение могло поместиться именно в 1 сегмент.
*	malloc() возвращает указатель типа int*. В отличие boost::simple_segregated_storage в примере , не требуется оператор приведения
*	construct() аналогично , malloc() но инициализирует объект с помощью вызова конструктора. В примере , J относится к int объекту инициализируется значением 2.
*	Пожалуйста , обратите внимание , что бассейн может вернуть свободный сегмент из пула 32 сегментов , когда construct() используется. Вызов construct() не делает в примере запроса памяти из операционной системы.
*	Последняя функция примере является destroy(), который освобождает int объекты.

#### Изменение размера сегмента памяти с boost::object_pool
Вы можете передать два параметра в конструктор boost::object_pool. Первый параметр задает размер блока памяти , который boost::object_pool будет выделять , когда первый сегмент запрашивается вызовом malloc() или construct(). Второй параметр задает максимальный размер блока памяти для размещения.

```
#include <boost/pool/object_pool.hpp>
#include <iostream>

int main()
{
  boost::object_pool<int> pool{32, 0};
  pool.construct();
  std::cout << pool.get_next_size() << '\n';
  pool.set_next_size(8);
}
```
*	Если malloc() или construct() вызываются так часто , что все сегменты в блоке памяти уже используются, то при следующем вызове одной из этих функций заставит boost::object_pool выделить новый блок памяти, который будет вдвое больше, чем предыдущий
*	Размер будет удваивать каждый раз , выделенной с использованием Boost::object_pool
*	Второй параметр конструктора позволяет ограничить рост
*	Конструктор по умолчанию boost::object_pool делает то же самое, что и вызов конструктора в примере ранее. Первый параметр задает размер блока памяти до 32 int значений.
*	Второй параметр указывает , что не существует никакого максимального размера. Если 0 передается, boost::object_pool может удвоить размер блока памяти на неопределенное время 
*	Вызов construct() в примере делает пул , который выделит блок памяти из 32 int значений. Пул может обслуживать до 32 вызовов к malloc() или construct() без запроса памяти от операционной системы.
*	Если требуется больше памяти, следующий блок памяти для размещения будет занимать место для 64 int значений.
*	get_next_size() возвращает размер следующего блока памяти для размещения. Возвращает 64
*	set_next_size() позволяет установить размер следующего блока памяти
*	Обращение к set_next_size() изменениям размер следующего блока памяти выделить от 64 до 8 int значений.



